//
// OpenIrekia v2.0 Cliente Android
//
// Copyright 2009-2011 eFaber, S.L.
// Copyright 2009-2011 Ejie, S.A.
// Copyrigth 2009-2011 Dirección de Gobierno Abierto y Comunicación en Internet; 
//    Gobernu Irekirako eta Interneteko Komunikaziorako Zuzendaritza; Lehendakaritza.
//    Gobierno Vasco – Eusko Jaurlaritza 
// Licencia con arreglo a la EUPL, Versión 1.1 o –en cuanto sean aprobadas 
// por la Comisión Europea– versiones posteriores de la EUPL (la Licencia);
// Solo podrá usarse esta obra si se respeta la Licencia. Puede obtenerse una 
// copia de la Licencia en: http://ec.europa.eu/idabc/eupl 
// Salvo cuando lo exija la legislación aplicable o se acuerde por escrito, 
// el programa distribuido con arreglo a la Licencia se distribuye TAL CUAL,
// SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
// Véase la Licencia en el idioma concreto que rige los permisos y limitaciones 
// que establece la Licencia
//
//  http://open.irekia.net, openirekia@efaber.net

package net.efaber.irekia.news;

import static junit.framework.Assert.assertTrue;
import net.efaber.irekia.Formatter;
import net.efaber.irekia.Irekia;
import net.efaber.irekia.models.News_item;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.os.Message;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.view.View;
import android.widget.ImageView;

import com.github.droidfu.imageloader.ImageLoader;
import com.github.droidfu.imageloader.ImageLoaderHandler;

/** Custom class to draw our rows without constructing views.
 * Everything is done dynamically inside onDraw().
 */
public class News_row extends View
{
private News_item item;
private News_data data;
private Cached_data cached_data;
private float footer_height;
private Formatter formatter1, formatter2;
private ImageView remote_image;
private boolean remote_loaded;

/** Constructor.
 * Pass the element position to differentiate rows. A better constructor would
 * pass the item or something.
 */
public News_row(Context context, News_data data)
{
	super(context);
	footer_height = -1;
	this.data = data;

	formatter1 = new Formatter();
	formatter2 = new Formatter();
	remote_image = new ImageView(context);
}

/** Simple item setter.
 * Required to refresh internally cached values for drawing.
 */
public void set(News_item item)
{
	this.item = item;
	remote_loaded = false;
	footer_height = -1;
	remote_image.setTag(null);
	if (null != item.image)
		ImageLoader.start(item.image, new DefaultImageLoaderHandler());
	postInvalidate();
}

/** Indicates if this view is opaque.
 * @return This will always return true, in a hope it gets optimised.
 */
@Override
public boolean isOpaque()
{
	return true;
}

/** Refreshes the global cache shared by the list.
 * The cached_data is the private class Cached_data, which is generated by one
 * row but shared accross all of them. This method is meant to be called by the
 * parent adapter. Pass null for the first time, then the previously cached
 * data when you are calling this again another time.
 * @return Returns the new pointer to the cached data the adapter should
 * replace.
 */
public Object refresh_cache(Object previous_cached_data)
{
	assertTrue("Incorrect row construction with null data!", null != data);
	if (null == data)
		return previous_cached_data;

	if (null != previous_cached_data) {
		cached_data = (Cached_data)previous_cached_data;
		return cached_data;
	}

	cached_data = new Cached_data(data);
	return cached_data;
}

/** Draws the canvas.
 */
@Override
public void onDraw(Canvas canvas)
{
	super.onDraw(canvas);

	if (null == item || null == cached_data)
		return;

	if (isSelected() || isPressed())
		canvas.drawColor(data.back_highlight_color);
	else
		canvas.drawColor(data.back_normal_color);

	final float cell_h = getMeasuredHeight();
	final float cell_w = getMeasuredWidth() - Irekia.SCROLLBAR_SPACE;
	// Get the screen's density scale
	final float spadding = data.padding * Irekia.density;
	//final float scale = Irekia.density;

	// Should we push up space due to a footer?
	if (null != item.footer && footer_height < 0) {
		if (null == cached_data.footer_paint) {
			cached_data.footer_paint = new TextPaint(
				Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);
			cached_data.footer_paint.setColor(data.footer_color);
			cached_data.footer_paint.setTextSize(
				data.footer_size * Irekia.font_density);

			Paint.FontMetrics size = cached_data.footer_paint.getFontMetrics();
			cached_data.footer_height = size.bottom - size.top + size.leading;
		}
		footer_height = cached_data.footer_height;
	} else if (footer_height < 0) {
		footer_height = 0;
	}

	final boolean show_image = (null != item.image);

	// Calculate text position for the first title bold line.
	float x = spadding;
	float y = spadding;
	final float image_w = data.image_w * Irekia.density;
	final float image_h = data.image_h * Irekia.density;
	if (show_image && !data.image_right)
		x += image_w + spadding;

	// Preload default disclosure image if none is provided by the overlord.
	if (null == data.item_disclosure) {
		data.item_disclosure = Irekia.get_disclosure_icon(
			getContext().getResources());
	}

	final float disclosure_width = (null == item.url) ? 0 :
		(null != data.item_disclosure ? data.item_disclosure.getWidth() : 0) +
			spadding;

	final float usable_width = cell_w - 2 * spadding - disclosure_width -
		(show_image ? image_w : 0);
	final float usable_height = cell_h - 2 * spadding - footer_height;

	// Debug drawable area.
	/*
	Paint red = new Paint();
	red.setColor(Color.RED);
	canvas.drawRect(x, y, x + usable_width, y + usable_height, red);
	*/

	canvas.save();
	StaticLayout l = formatter1.build(item.title,
		cached_data.title_paint, (int)(usable_width + 0.5f), data.title_lines);
	canvas.translate(x, y);
	l.draw(canvas);
	canvas.restore();
	final float used_height = l.getHeight();
	y += used_height;

	if (cached_data.body_line_height > 0) {
		// The +0.2 is a tweak to allow overdrawing body text over the footer
		// even though we shouldn't, but since Android fonts leave a lot of
		// space below, this seems to fit the area better.
		final int max_lines = (int)((usable_height - used_height) /
			cached_data.body_line_height + 0.2);

		if (max_lines > 0) {
			l = formatter2.build(item.body, cached_data.body_paint,
				(int)(usable_width + 0.5f), max_lines);
			canvas.save();
			canvas.translate(x, y);
			l.draw(canvas);
			canvas.restore();
		}
	}

	// Show the image, if any is available.
	if (show_image) {
		Rect r1 = cached_data.rect1;
		RectF r2 = cached_data.rect2;
		r2.set(spadding, spadding, spadding + image_w,
			(int)Math.min(cell_h - 2 * spadding, image_h));

		// Are we right aligned?
		if (data.image_right) {
			r2.right = cell_w - disclosure_width;
			r2.left = r2.right - image_w;
		}

		if (remote_loaded) {
			// We got it! Paint it.
			Drawable d = remote_image.getDrawable();
			d.setBounds((int)r2.left, (int)r2.top,
				(int)r2.right, (int)r2.bottom);
			d.draw(canvas);
		} else {
			// Draw the loading bitmap.
			if (null == cached_data.loading) {
				cached_data.loading = Irekia.get_loading_icon(
					getContext().getResources(), r2);
			}
			r1.set(0, 0, cached_data.loading.getWidth(),
				cached_data.loading.getHeight());
			canvas.drawBitmap(cached_data.loading, r1, r2,
				cached_data.body_paint);
		}
	}

	// Draw the disclosure button if there is content.
	if (disclosure_width > 0) {
		Rect r1 = cached_data.rect1;
		RectF r2 = cached_data.rect2;
		r1.set(0, 0, data.item_disclosure.getWidth(),
			data.item_disclosure.getHeight());

		final float button_height = Math.min(cell_h - 2 * spadding,
			data.item_disclosure.getHeight());

		r2.set(cell_w - disclosure_width + spadding,
			(int)(cell_h / 2 - button_height / 2),
			disclosure_width - spadding, (int)(button_height));
		r2.bottom += r2.top;
		r2.right += r2.left;

		canvas.drawBitmap(data.item_disclosure, r1, r2, cached_data.body_paint);
	}

	// Show the item's footer text.
	if (null != item.footer) {
		x = spadding;
		y = cell_h - spadding - footer_height;

		// Debug drawable area.
		/*
		Paint yellow = new Paint();
		yellow.setColor(Color.YELLOW);
		canvas.drawRect(x, y, x + (cell_w - 2 * spadding),
			y + footer_height, yellow);
		*/
		y -= cached_data.footer_paint.ascent();

		// Do we draw on the left, or do we require more complex calculations?
		if (data.footer_alignment < 0) {
			canvas.drawText(item.footer, x, y, cached_data.footer_paint);
		} else {
			// For right/center alignment we have to precalculate the length.
			final float footer_width = Math.min(usable_width,
				cached_data.footer_paint.measureText(item.footer));

			if (data.footer_alignment > 0)
				x = cell_w - spadding - footer_width;
			else
				x = (int)((cell_w - footer_width) / 2.0f);

			canvas.drawText(item.footer, x, y, cached_data.footer_paint);
		}
	}
}

@Override
public void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
{
	super.onMeasure(widthMeasureSpec, heightMeasureSpec);
	final int width = MeasureSpec.getSize(widthMeasureSpec);
	setMeasuredDimension(width, (int)(data.row_height * Irekia.density + 0.5f));
}

/***************************************************************************/

/** Holds objects that should be created once per list usage.
 */
private class Cached_data
{
public TextPaint title_paint, body_paint, footer_paint;
public Rect rect1;
public RectF rect2;
public final float body_line_height;
public float footer_height;
public Bitmap loading;

public Cached_data(News_data data)
{
	title_paint = new TextPaint(Paint.ANTI_ALIAS_FLAG |
		Paint.DEV_KERN_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
	title_paint.setColor(data.title_color);
	title_paint.setTextSize(data.title_size * Irekia.font_density);

	body_paint = new TextPaint(Paint.ANTI_ALIAS_FLAG |
		Paint.DEV_KERN_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
	body_paint.setColor(data.text_color);
	body_paint.setTextSize(data.text_size * Irekia.font_density);

	Paint.FontMetrics body_font = body_paint.getFontMetrics();
	body_line_height = body_font.bottom - body_font.top + body_font.leading;

	rect1 = new Rect();
	rect2 = new RectF();
}

}

/***************************************************************************/

/** Implements a custom load handler to notify the parent cell of changes.
 */
private class DefaultImageLoaderHandler extends ImageLoaderHandler
{
/// Use the item's identifier to detect if we are being on the correct row.
private final int item_id;

public DefaultImageLoaderHandler()
{
	super(remote_image, item.image, null);
	item_id = item.id;
}

/** Got an image, process the message.
 * We don't want to call the parent because we want to ignore all the error
 * image and other stuff. This will compare the current row identifer with the
 * one the row was assigned to avoid setting data in the bad cell.
 * @return Returns true if the remote image was loaded and set up correctly.
 */
@Override
protected boolean handleImageLoaded(Bitmap bitmap, Message msg)
{
	boolean updated = false;
	if (item.id == item_id && null != bitmap) {
		remote_loaded = true;
		remote_image.setImageBitmap(bitmap);
		invalidate();
		updated = true;
	}
	return updated;
}

}

}
